#!/usr/bin/env bun

// This script can be used to list available Apple simulators and install
// builds on them.

type Simulator = {
	udid: string;
	deviceIdentifier: string;
	state: string;
	name: string;
};

type Device = {
	identifier: string;
	name: string;
	deviceType: string;
};

import { Command, Argument } from "@commander-js/extra-typings";
import dedent from "dedent";
import { spawn } from "node:child_process";
import { writeFileSync, readFileSync, createWriteStream } from "node:fs";
import { moveCursor } from "node:readline";

const program = new Command();

const platforms = ["sim", "iOS", "macOS"] as const;
type Platform = (typeof platforms)[number];

const versionParts = ["major", "minor", "patch", "build"] as const;
type VersionPart = (typeof versionParts)[number];

const exportTypes: Record<Exclude<Platform, "sim">, string> = {
	iOS: "ios",
	macOS: "macos",
};

const buildDir = ".build";

program
	.name("dev")
	.description("Dev tools")
	.configureHelp({ sortSubcommands: true })
	.showHelpAfterError()
	.version("1.0.0");

program
	.command("build")
	.description("Build the extension")
	.addArgument(
		new Argument("<platform>", "Platform to build for").choices(platforms),
	)
	.option("--adhoc", "If platform is macOS, create an adhoc build")
	.option("--dev", "If true, build in dev mode")
	.action(async (platform, options) => {
		loadEnv(options?.dev ? "dev" : "prod");

		if (platform === "sim") {
			await buildSimApp();
		} else {
			await buildApp(platform, { adhoc: options.adhoc });
		}
	});

program
	.command("list")
	.description("List active devices or simulators")
	.addArgument(
		new Argument("<platform>", "Platform to build for").choices(platforms),
	)
	.action(async (platform) => {
		if (platform === "sim") {
			const sims = await getSimulators();
			for (const sim of sims) {
				console.log(`${sim.udid}: ${sim.name}`);
			}
		} else {
			const devs = await getDevices();
			for (const dev of devs) {
				console.log(`${dev.identifier}: ${dev.name}`);
			}
		}
	});

program
	.command("install")
	.description("Install a build on a device or simulator")
	.argument("<app>", "Path to app bundle")
	.option("-u, --udid <udid>", "UDID to install to, or 'local' for host Mac")
	.action(async (app, options) => {
		const id = options?.udid;

		if (app.endsWith(".app")) {
			if (id === "local") {
				await run("mv", [app, `/Applications/SpellingBeePlus.app`]);
			} else {
				const udid = id
					? await getMatchingSimId(id)
					: (await getSimulators())[0].udid;
				print(`ðŸ”¨ Installing ${app} on device ${udid}...\n`);
				await run("xcrun", ["simctl", "install", udid, app], {
					inheritStdio: true,
				});
			}
			print("ðŸš€ Done!\n");
		} else {
			const identifier = id
				? await getMatchingDeviceId(id)
				: (await getDevices())[0].identifier;
			print(`ðŸ”¨ Installing ${app} on device ${identifier}...\n`);
			await run("xcrun", [
				"devicectl",
				"device",
				"install",
				"app",
				"--device",
				identifier,
				app,
			]);
			print("ðŸš€ Done!\n");
		}
	});

program
	.command("upload")
	.description("Upload a build to the app store")
	.argument("<app>", "Path to app bundle")
	.action(async (app) => {
		loadEnv("prod");
		await uploadApp(app);
	});

program
	.command("version")
	.description("Show or update the current project version")
	.addArgument(new Argument("[part]", "Part to bump").choices(versionParts))
	.action(async (part) => {
		getSetVersion(part!);
	});

process.on("SIGINT", () => {
	showCursor();
	process.exit();
});

try {
	await program.parseAsync();
} catch (error) {
	console.error("ðŸš¨ Error:", error);
}

async function getSimulators(): Promise<Simulator[]> {
	const { output } = await run("xcrun", ["simctl", "list", "--json"]);

	const simInfo: { devices: { [runtime: string]: Simulator[] } } = JSON.parse(
		output.trim(),
	);

	const sims: Simulator[] = [];

	for (const sim of Object.values(simInfo.devices)) {
		for (const dev of sim) {
			if (dev.state === "Booted") {
				sims.push(dev);
			}
		}
	}

	return sims;
}

async function getDevices(): Promise<Device[]> {
	await run("xcrun", [
		"devicectl",
		"list",
		"devices",
		"--json-output",
		".devctl.json",
		"-q",
	]);

	const deviceInfo = JSON.parse(
		readFileSync(".devctl.json", { encoding: "utf8" }),
	) as {
		result: {
			devices: {
				identifier: string;
				connectionProperties: {
					pairingState: string;
					tunnelState: string;
				};
				deviceProperties: {
					name: string;
				};
				hardwareProperties: {
					deviceType: string;
				};
			}[];
		};
	};
	await run("rm", [".devctl.json"]);

	const devices: Device[] = [];

	for (const device of deviceInfo.result.devices) {
		if (
			device.connectionProperties.pairingState === "paired" &&
			device.connectionProperties.tunnelState !== "unavailable"
		) {
			devices.push({
				identifier: device.identifier,
				name: device.deviceProperties.name,
				deviceType: device.hardwareProperties.deviceType,
			});
		}
	}

	return devices;
}

async function getMatchingSimId(partialUdid: string) {
	const sims = await getSimulators();

	partialUdid = partialUdid.toUpperCase();

	const sim = sims.find((s) => s.udid.startsWith(partialUdid));
	if (sim) {
		return sim.udid;
	}

	throw new Error(`Invalid partial device ID "${partialUdid}"`);
}

async function getMatchingDeviceId(partialIdentifier: string) {
	const devs = await getDevices();

	partialIdentifier = partialIdentifier.toUpperCase();

	const dev = devs.find((d) => d.identifier.startsWith(partialIdentifier));
	if (dev) {
		return dev.identifier;
	}

	throw new Error(`Invalid partial device ID "${partialIdentifier}"`);
}

async function run(
	cmd: string,
	args: string[],
	opts?: { logFile?: string; inheritStdio?: boolean },
): Promise<{
	output: string;
	status: number | null;
}> {
	return new Promise((resolve, reject) => {
		const proc = spawn(cmd, args, {
			stdio: opts?.inheritStdio ? "inherit" : "pipe",
		});
		let output = "";

		if (opts?.logFile) {
			const logstream = createWriteStream(opts.logFile);
			proc.stdout?.pipe(logstream);
			proc.stderr?.pipe(logstream);
		} else if (!opts?.inheritStdio) {
			proc.stdout?.setEncoding("utf8");
			proc.stderr?.setEncoding("utf8");
			proc.stdout?.on("data", (chunk) => (output += chunk));
			proc.stderr?.on("data", (chunk) => (output += chunk));
		}

		proc.on("exit", (status) => {
			if (status !== 0) {
				const error = new Error(`command '${cmd}' failed`);
				reject({ error, output });
			} else {
				resolve({
					output,
					status,
				});
			}
		});
	});
}

function hideCursor() {
	process.stdout.write("\u001B[?25l");
}

function showCursor() {
	process.stdout.write("\u001B[?25h");
}

async function spin<T>(callback: () => Promise<T>): Promise<T> {
	const out = process.stdout;
	const spinners = ["â ‹", "â ™", "â ¹", "â ¸", "â ¼", "â ´", "â ¦", "â §", "â ‡", "â "];
	let index = 0;

	hideCursor();

	const interval = setInterval(() => {
		let line = spinners[index];
		out.write(line);
		moveCursor(out, -1, 0);
		index = (index + 1) % spinners.length;
	}, 100);

	try {
		return await callback();
	} finally {
		clearInterval(interval);
		out.write(" ");
		showCursor();
	}
}

function print(str: string) {
	process.stdout.write(str);
}

function loadEnv(envName: "dev" | "prod"): Record<string, string> {
	const env = JSON.parse(
		readFileSync(`env.${envName}.json`, { encoding: "utf8" }),
	);
	for (const key of Object.keys(env)) {
		process.env[key] = env[key];
	}

	const xcconfig: string[] = [];
	for (const key of Object.keys(env)) {
		xcconfig.push(`${key}=${env[key]}`);
	}

	writeFileSync("env.xcconfig", xcconfig.join("\n"));

	return env;
}

function getSetVersion(part: VersionPart) {
	const projectFile = "SpellingBeePlus.xcodeproj/project.pbxproj";
	const projectLines = readFileSync(projectFile, {
		encoding: "utf8",
	}).split("\n");

	const buildNumberLines: { line: string; i: number }[] = findLines(
		projectLines,
		(line) => /\s+CURRENT_PROJECT_VERSION = \d+/.test(line),
	);
	if (buildNumberLines.length === 0) {
		throw new Error("missing build number");
	}
	const buildLine = projectLines[buildNumberLines[0].i];
	let build = Number(buildLine.split(" = ")[1].trim().replace(/;$/, ""));

	const versionLines = findLines(projectLines, (line) =>
		/\s+MARKETING_VERSION = \d+\.\d+\.\d+/.test(line),
	);
	if (versionLines.length === 0) {
		throw new Error("missing version");
	}
	const versionLine = projectLines[versionLines[0].i];
	let version = versionLine.split(" = ")[1].trim().replace(/;$/, "");

	if (!part) {
		print(`${version}(${build})\n`);
	} else {
		let [major, minor, patch] = version.split(".").map(Number);

		build += 1;

		switch (part) {
			case "major":
				major += 1;
				minor = 0;
				patch = 0;
				break;
			case "minor":
				minor += 1;
				patch = 0;
				break;
			case "patch":
				patch += 1;
		}

		const buildLineParts = buildLine.split(" = ");
		for (const entry of buildNumberLines) {
			projectLines[entry.i] = `${buildLineParts[0]} = ${build};`;
		}

		const versionLineParts = versionLine.split(" = ");
		for (const entry of versionLines) {
			projectLines[entry.i] =
				`${versionLineParts[0]} = ${major}.${minor}.${patch};`;
		}

		writeFileSync(projectFile, projectLines.join("\n"));
	}
}

function findLines(
	lines: string[],
	test: (val: string) => boolean,
): { line: string; i: number }[] {
	return lines
		.map((line, i) => ({ line, i }))
		.filter((entry) => test(entry.line));
}

async function buildSimApp() {
	loadEnv("dev");

	print("ðŸ”¨ Building... ");

	try {
		await run("mkdir", ["-p", buildDir]);
		await spin(() =>
			run(
				"xcodebuild",
				[
					"-project",
					"SpellingBeePlus.xcodeproj",
					"-scheme",
					"SpellingBeePlus (iOS)",
					"-configuration",
					"Debug",
					"-sdk",
					"iphonesimulator",
					"-destination",
					"generic/platform=iOS Simulator",
					"-derivedDataPath",
					buildDir,
					"clean",
					"build",
				],
				{
					logFile: `${buildDir}/build.log`,
				},
			),
		);

		await run("mv", [
			`${buildDir}/Build/Products/Debug-iphonesimulator/SpellingBeePlus.app`,
			`build-${Date.now()}.app`,
		]);

		await run("rm", ["-rf", buildDir]);

		print("\nðŸš€ Done!\n");
	} catch (error) {
		print(`ðŸš¨ Build failed -- see logs in ${buildDir}\n`);
	}
}

async function buildApp(
	platform: Exclude<Platform, "sim">,
	options?: { adhoc?: boolean },
) {
	const archive = `${buildDir}/SpellingBeePlus.xcarchive`;
	const exportPath = `${buildDir}/export`;
	const exportOptionsFile = `${buildDir}/exportOptions.plist`;
	const exportPlists = {
		iOS: dedent`
			<?xml version=\"1.0\" encoding=\"UTF-8\"?>
			<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">
			<plist version=\"1.0\">
				<dict>
					<key>method</key>
					<string>release-testing</string>

					<key>teamID</key>
					<string>${getEnv("DEV_TEAM")}</string>
				</dict>
			</plist>
		`,
		macOS: dedent`
			<?xml version=\"1.0\" encoding=\"UTF-8\"?>
			<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">
			<plist version=\"1.0\">
				<dict>
					<key>method</key>
					<string>${options?.adhoc ? "mac-application" : "app-store-connect"}</string>

					<key>testFlightInternalTestingOnly</key>
					<true/>

					<key>teamID</key>
					<string>${getEnv("DEV_TEAM")}</string>
				</dict>
			</plist>
		`,
	};

	print(`ðŸ”¨ Building ${platform} app... `);

	try {
		await run("mkdir", ["-p", buildDir]);
		await spin(() =>
			run(
				"xcodebuild",
				[
					`DEV_TEAM=${getEnv("DEV_TEAM")}`,
					"-scheme",
					`SpellingBeePlus (${platform})`,
					"-destination",
					`generic/platform=${platform}`,
					"-archivePath",
					`${buildDir}/SpellingBeePlus.xcarchive`,
					"-allowProvisioningUpdates",
					"archive",
				],
				{ logFile: `${buildDir}/archive.log` },
			),
		);

		print("\n");
		writeFileSync(exportOptionsFile, exportPlists[platform]);
		print(`ðŸ“¦ Exporting ${platform} app... `);

		const ext = getExportExt(platform, options);

		await spin(() =>
			run(
				"xcodebuild",
				[
					`DEV_TEAM=${getEnv("DEV_TEAM")}`,
					"-exportArchive",
					"-allowProvisioningUpdates",
					"-archivePath",
					archive,
					"-exportPath",
					exportPath,
					"-exportOptionsPlist",
					exportOptionsFile,
				],
				{ logFile: `${buildDir}/export.log` },
			),
		);

		await run("mv", [
			`${exportPath}/SpellingBeePlus.${ext}`,
			`build-${Date.now()}.${ext}`,
		]);

		await run("rm", ["-rf", buildDir]);

		print("\nðŸš€ Done!\n");
	} catch {
		print(`ðŸš¨ Build failed -- see logs in ${buildDir}\n`);
	}
}

async function uploadApp(app: string, options?: { validate?: boolean }) {
	const ext = app.split(".").pop();
	const platform: Platform = ext === "pkg" ? "macOS" : "iOS";

	const { output } = await run("op", ["read", getEnv("DEV_PASSWORD")]);
	const devPassword = output.trim();

	print(`ðŸ“¤ Uploading ${app}... `);

	await run("mkdir", ["-p", buildDir]);

	try {
		await spin(() =>
			run(
				"xcrun",
				[
					"altool",
					options?.validate ? "--validate-app" : "--upload-app",
					"--file",
					app,
					"--username",
					getEnv("DEV_USERNAME"),
					"--password",
					devPassword,
					"--type",
					exportTypes[platform],
				],
				{ logFile: `${buildDir}/upload.log` },
			),
		);
		print("\nðŸš€ Done!\n");
	} catch (error) {
		print("\n");
		throw error;
	}
}

function getEnv(name: string): string {
	const val = process.env[name];
	if (val === undefined) {
		throw new Error(`${name} must be defined`);
	}
	return val;
}

function getExportExt(
	platform: Exclude<Platform, "sim">,
	options?: { adhoc?: boolean },
) {
	if (platform === "macOS") {
		if (options?.adhoc) {
			return "app";
		}
		return "pkg";
	}
	return "ipa";
}
